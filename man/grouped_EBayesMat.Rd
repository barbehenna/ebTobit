% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grouped_EBayesMat.R
\name{grouped_EBayesMat}
\alias{grouped_EBayesMat}
\title{Grouped Empirical Bayes Matrix Estimator}
\usage{
grouped_EBayesMat(
  L,
  R = L,
  gr = (L + R)/2,
  s1 = 1,
  group = integer(nrow(L)),
  algorithm = "EM",
  ...
)
}
\arguments{
\item{L}{n x p matrix of lower bounds on observations}

\item{R}{n x p matrix of upper bounds on observations}

\item{gr}{m x p matrix of candidate means (MLE by default)}

\item{s1}{n x p matrix of standard deviations for every observation}

\item{group}{grouping variable denoting which rows follow which priors,
refer to details for more}

\item{algorithm}{method to fit prior, see \code{\link{EBayesMat}} for more
details}

\item{...}{further arguments passed into fitting method}
}
\value{
a fitted posterior mean matrix (n x p)
}
\description{
A user-friendly interface for \code{\link{EBayesMat}} that allows for the
inclusion of group side-information. For each level in \code{factor(group)} a
different prior is fit and used when computing the estimate. This is useful
for conveying side information, but should be used with caution because
unnecessary grouping may worsen the performance due to decreased sample size
within each group.
}
\details{
The data are assumed to be partially interval censored, so that each element
in the matrix is represented as a pair of lower and upper bounds (L_ij,
R_ij). If the bounds are equal then there is a direct observation, if the
bounds are different then the observation is known to lie in the specified
interval. This format allows for directly observed data along with left-,
right-, and interval-censored observations. Each rows of L and R are
observations or bounds in R^p.
}
\examples{
set.seed(1)
n <- 100
p <- 2
TH <- cbind(rnorm(n), rnorm(n, mean = c(0,5)))
X <- TH + matrix(rnorm(n*p), n, p)
fit0 <- grouped_EBayesMat(X, s1 = matrix(1, n, p))
all.equal(fit0, fitted(EBayesMat(X)))

fit1 <- grouped_EBayesMat(X, s1 = matrix(1, n, p), group = TH[,2] > 2) # adding side information
mean((TH - fit0)^2) > mean((TH - fit1)^2)
}
